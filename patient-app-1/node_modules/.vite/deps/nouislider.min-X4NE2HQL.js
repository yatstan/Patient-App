import {
  __commonJS
} from "./chunk-L6OFPWCY.js";

// node_modules/svelte-materialify/dist/components/Slider/nouislider.min.js
var require_nouislider_min = __commonJS({
  "node_modules/svelte-materialify/dist/components/Slider/nouislider.min.js"(exports, module) {
    !function(t) {
      "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? module.exports = t() : window.noUiSlider = t();
    }(function() {
      "use strict";
      var lt = "14.6.1";
      function ut(t) {
        t.parentElement.removeChild(t);
      }
      function a(t) {
        return null != t;
      }
      function ct(t) {
        t.preventDefault();
      }
      function o(t) {
        return "number" == typeof t && !isNaN(t) && isFinite(t);
      }
      function pt(t, e2, r2) {
        0 < r2 && (ht(t, e2), setTimeout(function() {
          mt(t, e2);
        }, r2));
      }
      function ft(t) {
        return Math.max(Math.min(t, 100), 0);
      }
      function dt(t) {
        return Array.isArray(t) ? t : [t];
      }
      function e(t) {
        var e2 = (t = String(t)).split(".");
        return 1 < e2.length ? e2[1].length : 0;
      }
      function ht(t, e2) {
        t.classList && !/\s/.test(e2) ? t.classList.add(e2) : t.className += " " + e2;
      }
      function mt(t, e2) {
        t.classList && !/\s/.test(e2) ? t.classList.remove(e2) : t.className = t.className.replace(
          new RegExp("(^|\\b)" + e2.split(" ").join("|") + "(\\b|$)", "gi"),
          " "
        );
      }
      function gt(t) {
        var e2 = void 0 !== window.pageXOffset, r2 = "CSS1Compat" === (t.compatMode || "");
        return {
          x: e2 ? window.pageXOffset : r2 ? t.documentElement.scrollLeft : t.body.scrollLeft,
          y: e2 ? window.pageYOffset : r2 ? t.documentElement.scrollTop : t.body.scrollTop
        };
      }
      function c(t, e2) {
        return 100 / (e2 - t);
      }
      function p(t, e2, r2) {
        return 100 * e2 / (t[r2 + 1] - t[r2]);
      }
      function f(t, e2) {
        for (var r2 = 1; t >= e2[r2]; ) r2 += 1;
        return r2;
      }
      function r(t, e2, r2) {
        if (r2 >= t.slice(-1)[0]) return 100;
        var n2, i2, o2 = f(r2, t), s2 = t[o2 - 1], a2 = t[o2], l2 = e2[o2 - 1], u2 = e2[o2];
        return l2 + (i2 = r2, p(n2 = [s2, a2], n2[0] < 0 ? i2 + Math.abs(n2[0]) : i2 - n2[0], 0) / c(l2, u2));
      }
      function n(t, e2, r2, n2) {
        if (100 === n2) return n2;
        var i2, o2, s2 = f(n2, t), a2 = t[s2 - 1], l2 = t[s2];
        return r2 ? (l2 - a2) / 2 < n2 - a2 ? l2 : a2 : e2[s2 - 1] ? t[s2 - 1] + (i2 = n2 - t[s2 - 1], o2 = e2[s2 - 1], Math.round(i2 / o2) * o2) : n2;
      }
      function s(t, e2, r2) {
        var n2;
        if ("number" == typeof e2 && (e2 = [e2]), !Array.isArray(e2))
          throw new Error("noUiSlider (" + lt + "): 'range' contains invalid value.");
        if (!o(n2 = "min" === t ? 0 : "max" === t ? 100 : parseFloat(t)) || !o(e2[0]))
          throw new Error("noUiSlider (" + lt + "): 'range' value isn't numeric.");
        r2.xPct.push(n2), r2.xVal.push(e2[0]), n2 ? r2.xSteps.push(!isNaN(e2[1]) && e2[1]) : isNaN(e2[1]) || (r2.xSteps[0] = e2[1]), r2.xHighestCompleteStep.push(0);
      }
      function l(t, e2, r2) {
        if (e2)
          if (r2.xVal[t] !== r2.xVal[t + 1]) {
            r2.xSteps[t] = p([r2.xVal[t], r2.xVal[t + 1]], e2, 0) / c(r2.xPct[t], r2.xPct[t + 1]);
            var n2 = (r2.xVal[t + 1] - r2.xVal[t]) / r2.xNumSteps[t], i2 = Math.ceil(Number(n2.toFixed(3)) - 1), o2 = r2.xVal[t] + r2.xNumSteps[t] * i2;
            r2.xHighestCompleteStep[t] = o2;
          } else r2.xSteps[t] = r2.xHighestCompleteStep[t] = r2.xVal[t];
      }
      function i(t, e2, r2) {
        var n2;
        this.xPct = [], this.xVal = [], this.xSteps = [r2 || false], this.xNumSteps = [false], this.xHighestCompleteStep = [], this.snap = e2;
        var i2 = [];
        for (n2 in t) t.hasOwnProperty(n2) && i2.push([t[n2], n2]);
        for (i2.length && "object" == typeof i2[0][0] ? i2.sort(function(t2, e3) {
          return t2[0][0] - e3[0][0];
        }) : i2.sort(function(t2, e3) {
          return t2[0] - e3[0];
        }), n2 = 0; n2 < i2.length; n2++)
          s(i2[n2][1], i2[n2][0], this);
        for (this.xNumSteps = this.xSteps.slice(0), n2 = 0; n2 < this.xNumSteps.length; n2++)
          l(n2, this.xNumSteps[n2], this);
      }
      i.prototype.getDistance = function(t) {
        var e2, r2 = [];
        for (e2 = 0; e2 < this.xNumSteps.length - 1; e2++) {
          var n2 = this.xNumSteps[e2];
          if (n2 && t / n2 % 1 != 0)
            throw new Error(
              "noUiSlider (" + lt + "): 'limit', 'margin' and 'padding' of " + this.xPct[e2] + "% range must be divisible by step."
            );
          r2[e2] = p(this.xVal, t, e2);
        }
        return r2;
      }, i.prototype.getAbsoluteDistance = function(t, e2, r2) {
        var n2, i2 = 0;
        if (t < this.xPct[this.xPct.length - 1]) for (; t > this.xPct[i2 + 1]; ) i2++;
        else t === this.xPct[this.xPct.length - 1] && (i2 = this.xPct.length - 2);
        r2 || t !== this.xPct[i2 + 1] || i2++;
        var o2 = 1, s2 = e2[i2], a2 = 0, l2 = 0, u2 = 0, c2 = 0;
        for (n2 = r2 ? (t - this.xPct[i2]) / (this.xPct[i2 + 1] - this.xPct[i2]) : (this.xPct[i2 + 1] - t) / (this.xPct[i2 + 1] - this.xPct[i2]); 0 < s2; )
          a2 = this.xPct[i2 + 1 + c2] - this.xPct[i2 + c2], 100 < e2[i2 + c2] * o2 + 100 - 100 * n2 ? (l2 = a2 * n2, o2 = (s2 - 100 * n2) / e2[i2 + c2], n2 = 1) : (l2 = e2[i2 + c2] * a2 / 100 * o2, o2 = 0), r2 ? (u2 -= l2, 1 <= this.xPct.length + c2 && c2--) : (u2 += l2, 1 <= this.xPct.length - c2 && c2++), s2 = e2[i2 + c2] * o2;
        return t + u2;
      }, i.prototype.toStepping = function(t) {
        return t = r(this.xVal, this.xPct, t);
      }, i.prototype.fromStepping = function(t) {
        return function(t2, e2, r2) {
          if (100 <= r2) return t2.slice(-1)[0];
          var n2, i2 = f(r2, e2), o2 = t2[i2 - 1], s2 = t2[i2], a2 = e2[i2 - 1], l2 = e2[i2];
          return n2 = [o2, s2], (r2 - a2) * c(a2, l2) * (n2[1] - n2[0]) / 100 + n2[0];
        }(this.xVal, this.xPct, t);
      }, i.prototype.getStep = function(t) {
        return t = n(this.xPct, this.xSteps, this.snap, t);
      }, i.prototype.getDefaultStep = function(t, e2, r2) {
        var n2 = f(t, this.xPct);
        return (100 === t || e2 && t === this.xPct[n2 - 1]) && (n2 = Math.max(n2 - 1, 1)), (this.xVal[n2] - this.xVal[n2 - 1]) / r2;
      }, i.prototype.getNearbySteps = function(t) {
        var e2 = f(t, this.xPct);
        return {
          stepBefore: {
            startValue: this.xVal[e2 - 2],
            step: this.xNumSteps[e2 - 2],
            highestStep: this.xHighestCompleteStep[e2 - 2]
          },
          thisStep: {
            startValue: this.xVal[e2 - 1],
            step: this.xNumSteps[e2 - 1],
            highestStep: this.xHighestCompleteStep[e2 - 1]
          },
          stepAfter: {
            startValue: this.xVal[e2],
            step: this.xNumSteps[e2],
            highestStep: this.xHighestCompleteStep[e2]
          }
        };
      }, i.prototype.countStepDecimals = function() {
        var t = this.xNumSteps.map(e);
        return Math.max.apply(null, t);
      }, i.prototype.convert = function(t) {
        return this.getStep(this.toStepping(t));
      };
      var u = {
        to: function(t) {
          return void 0 !== t && t.toFixed(2);
        },
        from: Number
      }, d = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
      };
      function h(t) {
        if ("object" == typeof (e2 = t) && "function" == typeof e2.to && "function" == typeof e2.from)
          return true;
        var e2;
        throw new Error(
          "noUiSlider (" + lt + "): 'format' requires 'to' and 'from' methods."
        );
      }
      function m(t, e2) {
        if (!o(e2)) throw new Error("noUiSlider (" + lt + "): 'step' is not numeric.");
        t.singleStep = e2;
      }
      function g(t, e2) {
        if (!o(e2))
          throw new Error(
            "noUiSlider (" + lt + "): 'keyboardPageMultiplier' is not numeric."
          );
        t.keyboardPageMultiplier = e2;
      }
      function v(t, e2) {
        if (!o(e2))
          throw new Error("noUiSlider (" + lt + "): 'keyboardDefaultStep' is not numeric.");
        t.keyboardDefaultStep = e2;
      }
      function b(t, e2) {
        if ("object" != typeof e2 || Array.isArray(e2))
          throw new Error("noUiSlider (" + lt + "): 'range' is not an object.");
        if (void 0 === e2.min || void 0 === e2.max)
          throw new Error("noUiSlider (" + lt + "): Missing 'min' or 'max' in 'range'.");
        if (e2.min === e2.max)
          throw new Error(
            "noUiSlider (" + lt + "): 'range' 'min' and 'max' cannot be equal."
          );
        t.spectrum = new i(e2, t.snap, t.singleStep);
      }
      function x(t, e2) {
        if (e2 = dt(e2), !Array.isArray(e2) || !e2.length)
          throw new Error("noUiSlider (" + lt + "): 'start' option is incorrect.");
        t.handles = e2.length, t.start = e2;
      }
      function S(t, e2) {
        if ("boolean" != typeof (t.snap = e2))
          throw new Error("noUiSlider (" + lt + "): 'snap' option must be a boolean.");
      }
      function w(t, e2) {
        if ("boolean" != typeof (t.animate = e2))
          throw new Error("noUiSlider (" + lt + "): 'animate' option must be a boolean.");
      }
      function y(t, e2) {
        if ("number" != typeof (t.animationDuration = e2))
          throw new Error(
            "noUiSlider (" + lt + "): 'animationDuration' option must be a number."
          );
      }
      function E(t, e2) {
        var r2, n2 = [false];
        if ("lower" === e2 ? e2 = [true, false] : "upper" === e2 && (e2 = [false, true]), true === e2 || false === e2) {
          for (r2 = 1; r2 < t.handles; r2++) n2.push(e2);
          n2.push(false);
        } else {
          if (!Array.isArray(e2) || !e2.length || e2.length !== t.handles + 1)
            throw new Error(
              "noUiSlider (" + lt + "): 'connect' option doesn't match handle count."
            );
          n2 = e2;
        }
        t.connect = n2;
      }
      function C(t, e2) {
        switch (e2) {
          case "horizontal":
            t.ort = 0;
            break;
          case "vertical":
            t.ort = 1;
            break;
          default:
            throw new Error("noUiSlider (" + lt + "): 'orientation' option is invalid.");
        }
      }
      function P(t, e2) {
        if (!o(e2))
          throw new Error("noUiSlider (" + lt + "): 'margin' option must be numeric.");
        0 !== e2 && (t.margin = t.spectrum.getDistance(e2));
      }
      function N(t, e2) {
        if (!o(e2))
          throw new Error("noUiSlider (" + lt + "): 'limit' option must be numeric.");
        if (t.limit = t.spectrum.getDistance(e2), !t.limit || t.handles < 2)
          throw new Error(
            "noUiSlider (" + lt + "): 'limit' option is only supported on linear sliders with 2 or more handles."
          );
      }
      function k(t, e2) {
        var r2;
        if (!o(e2) && !Array.isArray(e2))
          throw new Error(
            "noUiSlider (" + lt + "): 'padding' option must be numeric or array of exactly 2 numbers."
          );
        if (Array.isArray(e2) && 2 !== e2.length && !o(e2[0]) && !o(e2[1]))
          throw new Error(
            "noUiSlider (" + lt + "): 'padding' option must be numeric or array of exactly 2 numbers."
          );
        if (0 !== e2) {
          for (Array.isArray(e2) || (e2 = [e2, e2]), t.padding = [t.spectrum.getDistance(e2[0]), t.spectrum.getDistance(e2[1])], r2 = 0; r2 < t.spectrum.xNumSteps.length - 1; r2++)
            if (t.padding[0][r2] < 0 || t.padding[1][r2] < 0)
              throw new Error(
                "noUiSlider (" + lt + "): 'padding' option must be a positive number(s)."
              );
          var n2 = e2[0] + e2[1], i2 = t.spectrum.xVal[0];
          if (1 < n2 / (t.spectrum.xVal[t.spectrum.xVal.length - 1] - i2))
            throw new Error(
              "noUiSlider (" + lt + "): 'padding' option must not exceed 100% of the range."
            );
        }
      }
      function U(t, e2) {
        switch (e2) {
          case "ltr":
            t.dir = 0;
            break;
          case "rtl":
            t.dir = 1;
            break;
          default:
            throw new Error(
              "noUiSlider (" + lt + "): 'direction' option was not recognized."
            );
        }
      }
      function A(t, e2) {
        if ("string" != typeof e2)
          throw new Error(
            "noUiSlider (" + lt + "): 'behaviour' must be a string containing options."
          );
        var r2 = 0 <= e2.indexOf("tap"), n2 = 0 <= e2.indexOf("drag"), i2 = 0 <= e2.indexOf("fixed"), o2 = 0 <= e2.indexOf("snap"), s2 = 0 <= e2.indexOf("hover"), a2 = 0 <= e2.indexOf("unconstrained");
        if (i2) {
          if (2 !== t.handles)
            throw new Error(
              "noUiSlider (" + lt + "): 'fixed' behaviour must be used with 2 handles"
            );
          P(t, t.start[1] - t.start[0]);
        }
        if (a2 && (t.margin || t.limit))
          throw new Error(
            "noUiSlider (" + lt + "): 'unconstrained' behaviour cannot be used with margin or limit"
          );
        t.events = { tap: r2 || o2, drag: n2, fixed: i2, snap: o2, hover: s2, unconstrained: a2 };
      }
      function V(t, e2) {
        if (false !== e2)
          if (true === e2) {
            t.tooltips = [];
            for (var r2 = 0; r2 < t.handles; r2++) t.tooltips.push(true);
          } else {
            if (t.tooltips = dt(e2), t.tooltips.length !== t.handles)
              throw new Error(
                "noUiSlider (" + lt + "): must pass a formatter for all handles."
              );
            t.tooltips.forEach(function(t2) {
              if ("boolean" != typeof t2 && ("object" != typeof t2 || "function" != typeof t2.to))
                throw new Error(
                  "noUiSlider (" + lt + "): 'tooltips' must be passed a formatter or 'false'."
                );
            });
          }
      }
      function D(t, e2) {
        h(t.ariaFormat = e2);
      }
      function M(t, e2) {
        h(t.format = e2);
      }
      function O(t, e2) {
        if ("boolean" != typeof (t.keyboardSupport = e2))
          throw new Error(
            "noUiSlider (" + lt + "): 'keyboardSupport' option must be a boolean."
          );
      }
      function L(t, e2) {
        t.documentElement = e2;
      }
      function z(t, e2) {
        if ("string" != typeof e2 && false !== e2)
          throw new Error(
            "noUiSlider (" + lt + "): 'cssPrefix' must be a string or `false`."
          );
        t.cssPrefix = e2;
      }
      function H(t, e2) {
        if ("object" != typeof e2)
          throw new Error("noUiSlider (" + lt + "): 'cssClasses' must be an object.");
        if ("string" == typeof t.cssPrefix)
          for (var r2 in t.cssClasses = {}, e2)
            e2.hasOwnProperty(r2) && (t.cssClasses[r2] = t.cssPrefix + e2[r2]);
        else t.cssClasses = e2;
      }
      function vt(e2) {
        var r2 = {
          margin: 0,
          limit: 0,
          padding: 0,
          animate: true,
          animationDuration: 300,
          ariaFormat: u,
          format: u
        }, n2 = {
          step: { r: false, t: m },
          keyboardPageMultiplier: { r: false, t: g },
          keyboardDefaultStep: { r: false, t: v },
          start: { r: true, t: x },
          connect: { r: true, t: E },
          direction: { r: true, t: U },
          snap: { r: false, t: S },
          animate: { r: false, t: w },
          animationDuration: { r: false, t: y },
          range: { r: true, t: b },
          orientation: { r: false, t: C },
          margin: { r: false, t: P },
          limit: { r: false, t: N },
          padding: { r: false, t: k },
          behaviour: { r: true, t: A },
          ariaFormat: { r: false, t: D },
          format: { r: false, t: M },
          tooltips: { r: false, t: V },
          keyboardSupport: { r: true, t: O },
          documentElement: { r: false, t: L },
          cssPrefix: { r: true, t: z },
          cssClasses: { r: true, t: H }
        }, i2 = {
          connect: false,
          direction: "ltr",
          behaviour: "tap",
          orientation: "horizontal",
          keyboardSupport: true,
          cssPrefix: "noUi-",
          cssClasses: d,
          keyboardPageMultiplier: 5,
          keyboardDefaultStep: 10
        };
        e2.format && !e2.ariaFormat && (e2.ariaFormat = e2.format), Object.keys(n2).forEach(function(t2) {
          if (!a(e2[t2]) && void 0 === i2[t2]) {
            if (n2[t2].r)
              throw new Error("noUiSlider (" + lt + "): '" + t2 + "' is required.");
            return true;
          }
          n2[t2].t(r2, a(e2[t2]) ? e2[t2] : i2[t2]);
        }), r2.pips = e2.pips;
        var t = document.createElement("div"), o2 = void 0 !== t.style.msTransform, s2 = void 0 !== t.style.transform;
        r2.transformRule = s2 ? "transform" : o2 ? "msTransform" : "webkitTransform";
        return r2.style = [
          ["left", "top"],
          ["right", "bottom"]
        ][r2.dir][r2.ort], r2;
      }
      function j(t, b2, o2) {
        var l2, u2, s2, c2, i2, a2, e2, p2, f2 = window.navigator.pointerEnabled ? { start: "pointerdown", move: "pointermove", end: "pointerup" } : window.navigator.msPointerEnabled ? { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" } : {
          start: "mousedown touchstart",
          move: "mousemove touchmove",
          end: "mouseup touchend"
        }, d2 = window.CSS && CSS.supports && CSS.supports("touch-action", "none") && function() {
          var t2 = false;
          try {
            var e3 = Object.defineProperty({}, "passive", {
              get: function() {
                t2 = true;
              }
            });
            window.addEventListener("test", null, e3);
          } catch (t3) {
          }
          return t2;
        }(), h2 = t, y2 = b2.spectrum, x2 = [], S2 = [], m2 = [], g2 = 0, v2 = {}, w2 = t.ownerDocument, E2 = b2.documentElement || w2.documentElement, C2 = w2.body, P2 = -1, N2 = 0, k2 = 1, U2 = 2, A2 = "rtl" === w2.dir || 1 === b2.ort ? 0 : 100;
        function V2(t2, e3) {
          var r3 = w2.createElement("div");
          return e3 && ht(r3, e3), t2.appendChild(r3), r3;
        }
        function D2(t2, e3) {
          var r3 = V2(t2, b2.cssClasses.origin), n3 = V2(r3, b2.cssClasses.handle);
          return V2(n3, b2.cssClasses.touchArea), n3.setAttribute("data-handle", e3), b2.keyboardSupport && (n3.setAttribute("tabindex", "0"), n3.addEventListener("keydown", function(t3) {
            return function(t4, e4) {
              if (O2() || L2(e4)) return false;
              var r4 = ["Left", "Right"], n4 = ["Down", "Up"], i3 = ["PageDown", "PageUp"], o3 = ["Home", "End"];
              b2.dir && !b2.ort ? r4.reverse() : b2.ort && !b2.dir && (n4.reverse(), i3.reverse());
              var s3, a3 = t4.key.replace("Arrow", ""), l3 = a3 === i3[0], u3 = a3 === i3[1], c3 = a3 === n4[0] || a3 === r4[0] || l3, p3 = a3 === n4[1] || a3 === r4[1] || u3, f3 = a3 === o3[0], d3 = a3 === o3[1];
              if (!(c3 || p3 || f3 || d3)) return true;
              if (t4.preventDefault(), p3 || c3) {
                var h3 = b2.keyboardPageMultiplier, m3 = c3 ? 0 : 1, g3 = at(e4), v3 = g3[m3];
                if (null === v3) return false;
                false === v3 && (v3 = y2.getDefaultStep(S2[e4], c3, b2.keyboardDefaultStep)), (u3 || l3) && (v3 *= h3), v3 = Math.max(v3, 1e-7), v3 *= c3 ? -1 : 1, s3 = x2[e4] + v3;
              } else s3 = d3 ? b2.spectrum.xVal[b2.spectrum.xVal.length - 1] : b2.spectrum.xVal[0];
              return rt(e4, y2.toStepping(s3), true, true), J("slide", e4), J("update", e4), J("change", e4), J("set", e4), false;
            }(t3, e3);
          })), n3.setAttribute("role", "slider"), n3.setAttribute("aria-orientation", b2.ort ? "vertical" : "horizontal"), 0 === e3 ? ht(n3, b2.cssClasses.handleLower) : e3 === b2.handles - 1 && ht(n3, b2.cssClasses.handleUpper), r3;
        }
        function M2(t2, e3) {
          return !!e3 && V2(t2, b2.cssClasses.connect);
        }
        function r2(t2, e3) {
          return !!b2.tooltips[e3] && V2(t2.firstChild, b2.cssClasses.tooltip);
        }
        function O2() {
          return h2.hasAttribute("disabled");
        }
        function L2(t2) {
          return u2[t2].hasAttribute("disabled");
        }
        function z2() {
          i2 && (G("update.tooltips"), i2.forEach(function(t2) {
            t2 && ut(t2);
          }), i2 = null);
        }
        function H2() {
          z2(), i2 = u2.map(r2), $("update.tooltips", function(t2, e3, r3) {
            if (i2[e3]) {
              var n3 = t2[e3];
              true !== b2.tooltips[e3] && (n3 = b2.tooltips[e3].to(r3[e3])), i2[e3].innerHTML = n3;
            }
          });
        }
        function j2(e3, i3, o3) {
          var s3 = w2.createElement("div"), a3 = [];
          a3[N2] = b2.cssClasses.valueNormal, a3[k2] = b2.cssClasses.valueLarge, a3[U2] = b2.cssClasses.valueSub;
          var l3 = [];
          l3[N2] = b2.cssClasses.markerNormal, l3[k2] = b2.cssClasses.markerLarge, l3[U2] = b2.cssClasses.markerSub;
          var u3 = [b2.cssClasses.valueHorizontal, b2.cssClasses.valueVertical], c3 = [b2.cssClasses.markerHorizontal, b2.cssClasses.markerVertical];
          function p3(t2, e4) {
            var r3 = e4 === b2.cssClasses.value, n3 = r3 ? a3 : l3;
            return e4 + " " + (r3 ? u3 : c3)[b2.ort] + " " + n3[t2];
          }
          return ht(s3, b2.cssClasses.pips), ht(s3, 0 === b2.ort ? b2.cssClasses.pipsHorizontal : b2.cssClasses.pipsVertical), Object.keys(e3).forEach(function(t2) {
            !function(t3, e4, r3) {
              if ((r3 = i3 ? i3(e4, r3) : r3) !== P2) {
                var n3 = V2(s3, false);
                n3.className = p3(r3, b2.cssClasses.marker), n3.style[b2.style] = t3 + "%", N2 < r3 && ((n3 = V2(s3, false)).className = p3(r3, b2.cssClasses.value), n3.setAttribute("data-value", e4), n3.style[b2.style] = t3 + "%", n3.innerHTML = o3.to(e4));
              }
            }(t2, e3[t2][0], e3[t2][1]);
          }), s3;
        }
        function F() {
          c2 && (ut(c2), c2 = null);
        }
        function R(t2) {
          F();
          var m3, g3, v3, b3, e3, r3, x3, S3, w3, n3 = t2.mode, i3 = t2.density || 1, o3 = t2.filter || false, s3 = function(t3, e4, r4) {
            if ("range" === t3 || "steps" === t3) return y2.xVal;
            if ("count" === t3) {
              if (e4 < 2)
                throw new Error(
                  "noUiSlider (" + lt + "): 'values' (>= 2) required for mode 'count'."
                );
              var n4 = e4 - 1, i4 = 100 / n4;
              for (e4 = []; n4--; ) e4[n4] = n4 * i4;
              e4.push(100), t3 = "positions";
            }
            return "positions" === t3 ? e4.map(function(t4) {
              return y2.fromStepping(r4 ? y2.getStep(t4) : t4);
            }) : "values" === t3 ? r4 ? e4.map(function(t4) {
              return y2.fromStepping(y2.getStep(y2.toStepping(t4)));
            }) : e4 : void 0;
          }(n3, t2.values || false, t2.stepped || false), a3 = (m3 = i3, g3 = n3, v3 = s3, b3 = {}, e3 = y2.xVal[0], r3 = y2.xVal[y2.xVal.length - 1], S3 = x3 = false, w3 = 0, (v3 = v3.slice().sort(function(t3, e4) {
            return t3 - e4;
          }).filter(function(t3) {
            return !this[t3] && (this[t3] = true);
          }, {}))[0] !== e3 && (v3.unshift(e3), x3 = true), v3[v3.length - 1] !== r3 && (v3.push(r3), S3 = true), v3.forEach(function(t3, e4) {
            var r4, n4, i4, o4, s4, a4, l4, u3, c3, p3, f3 = t3, d3 = v3[e4 + 1], h3 = "steps" === g3;
            if (h3 && (r4 = y2.xNumSteps[e4]), r4 || (r4 = d3 - f3), false !== f3)
              for (void 0 === d3 && (d3 = f3), r4 = Math.max(r4, 1e-7), n4 = f3; n4 <= d3; n4 = (n4 + r4).toFixed(7) / 1) {
                for (u3 = (s4 = (o4 = y2.toStepping(n4)) - w3) / m3, p3 = s4 / (c3 = Math.round(u3)), i4 = 1; i4 <= c3; i4 += 1)
                  b3[(a4 = w3 + i4 * p3).toFixed(5)] = [y2.fromStepping(a4), 0];
                l4 = -1 < v3.indexOf(n4) ? k2 : h3 ? U2 : N2, !e4 && x3 && n4 !== d3 && (l4 = 0), n4 === d3 && S3 || (b3[o4.toFixed(5)] = [n4, l4]), w3 = o4;
              }
          }), b3), l3 = t2.format || { to: Math.round };
          return c2 = h2.appendChild(j2(a3, o3, l3));
        }
        function T() {
          var t2 = l2.getBoundingClientRect(), e3 = "offset" + ["Width", "Height"][b2.ort];
          return 0 === b2.ort ? t2.width || l2[e3] : t2.height || l2[e3];
        }
        function B(n3, i3, o3, s3) {
          var e3 = function(t2) {
            return !!(t2 = function(t3, e5, r5) {
              var n4, i4, o4 = 0 === t3.type.indexOf("touch"), s4 = 0 === t3.type.indexOf("mouse"), a3 = 0 === t3.type.indexOf("pointer");
              0 === t3.type.indexOf("MSPointer") && (a3 = true);
              if (o4) {
                var l3 = function(t4) {
                  return t4.target === r5 || r5.contains(t4.target) || t4.target.shadowRoot && t4.target.shadowRoot.contains(r5);
                };
                if ("touchstart" === t3.type) {
                  var u3 = Array.prototype.filter.call(t3.touches, l3);
                  if (1 < u3.length) return false;
                  n4 = u3[0].pageX, i4 = u3[0].pageY;
                } else {
                  var c3 = Array.prototype.find.call(t3.changedTouches, l3);
                  if (!c3) return false;
                  n4 = c3.pageX, i4 = c3.pageY;
                }
              }
              e5 = e5 || gt(w2), (s4 || a3) && (n4 = t3.clientX + e5.x, i4 = t3.clientY + e5.y);
              return t3.pageOffset = e5, t3.points = [n4, i4], t3.cursor = s4 || a3, t3;
            }(t2, s3.pageOffset, s3.target || i3)) && !(O2() && !s3.doNotReject) && (e4 = h2, r4 = b2.cssClasses.tap, !((e4.classList ? e4.classList.contains(r4) : new RegExp("\\b" + r4 + "\\b").test(e4.className)) && !s3.doNotReject) && !(n3 === f2.start && void 0 !== t2.buttons && 1 < t2.buttons) && (!s3.hover || !t2.buttons) && (d2 || t2.preventDefault(), t2.calcPoint = t2.points[b2.ort], void o3(t2, s3)));
            var e4, r4;
          }, r3 = [];
          return n3.split(" ").forEach(function(t2) {
            i3.addEventListener(t2, e3, !!d2 && { passive: true }), r3.push([t2, e3]);
          }), r3;
        }
        function q(t2) {
          var e3, r3, n3, i3, o3, s3, a3 = 100 * (t2 - (e3 = l2, r3 = b2.ort, n3 = e3.getBoundingClientRect(), i3 = e3.ownerDocument, o3 = i3.documentElement, s3 = gt(i3), /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (s3.x = 0), r3 ? n3.top + s3.y - o3.clientTop : n3.left + s3.x - o3.clientLeft)) / T();
          return a3 = ft(a3), b2.dir ? 100 - a3 : a3;
        }
        function X(t2, e3) {
          "mouseout" === t2.type && "HTML" === t2.target.nodeName && null === t2.relatedTarget && _(t2, e3);
        }
        function Y(t2, e3) {
          if (-1 === navigator.appVersion.indexOf("MSIE 9") && 0 === t2.buttons && 0 !== e3.buttonsProperty)
            return _(t2, e3);
          var r3 = (b2.dir ? -1 : 1) * (t2.calcPoint - e3.startCalcPoint);
          Z(0 < r3, 100 * r3 / e3.baseSize, e3.locations, e3.handleNumbers);
        }
        function _(t2, e3) {
          e3.handle && (mt(e3.handle, b2.cssClasses.active), g2 -= 1), e3.listeners.forEach(function(t3) {
            E2.removeEventListener(t3[0], t3[1]);
          }), 0 === g2 && (mt(h2, b2.cssClasses.drag), et(), t2.cursor && (C2.style.cursor = "", C2.removeEventListener("selectstart", ct))), e3.handleNumbers.forEach(function(t3) {
            J("change", t3), J("set", t3), J("end", t3);
          });
        }
        function I(t2, e3) {
          if (e3.handleNumbers.some(L2)) return false;
          var r3;
          1 === e3.handleNumbers.length && (r3 = u2[e3.handleNumbers[0]].children[0], g2 += 1, ht(r3, b2.cssClasses.active));
          t2.stopPropagation();
          var n3 = [], i3 = B(f2.move, E2, Y, {
            target: t2.target,
            handle: r3,
            listeners: n3,
            startCalcPoint: t2.calcPoint,
            baseSize: T(),
            pageOffset: t2.pageOffset,
            handleNumbers: e3.handleNumbers,
            buttonsProperty: t2.buttons,
            locations: S2.slice()
          }), o3 = B(f2.end, E2, _, {
            target: t2.target,
            handle: r3,
            listeners: n3,
            doNotReject: true,
            handleNumbers: e3.handleNumbers
          }), s3 = B("mouseout", E2, X, {
            target: t2.target,
            handle: r3,
            listeners: n3,
            doNotReject: true,
            handleNumbers: e3.handleNumbers
          });
          n3.push.apply(n3, i3.concat(o3, s3)), t2.cursor && (C2.style.cursor = getComputedStyle(t2.target).cursor, 1 < u2.length && ht(h2, b2.cssClasses.drag), C2.addEventListener("selectstart", ct, false)), e3.handleNumbers.forEach(function(t3) {
            J("start", t3);
          });
        }
        function n2(t2) {
          if (!t2.buttons && !t2.touches) return false;
          t2.stopPropagation();
          var i3, o3, s3, e3 = q(t2.calcPoint), r3 = (i3 = e3, s3 = !(o3 = 100), u2.forEach(function(t3, e4) {
            if (!L2(e4)) {
              var r4 = S2[e4], n3 = Math.abs(r4 - i3);
              (n3 < o3 || n3 <= o3 && r4 < i3 || 100 === n3 && 100 === o3) && (s3 = e4, o3 = n3);
            }
          }), s3);
          if (false === r3) return false;
          b2.events.snap || pt(h2, b2.cssClasses.tap, b2.animationDuration), rt(r3, e3, true, true), et(), J("slide", r3, true), J("update", r3, true), J("change", r3, true), J("set", r3, true), b2.events.snap && I(t2, { handleNumbers: [r3] });
        }
        function W(t2) {
          var e3 = q(t2.calcPoint), r3 = y2.getStep(e3), n3 = y2.fromStepping(r3);
          Object.keys(v2).forEach(function(t3) {
            "hover" === t3.split(".")[0] && v2[t3].forEach(function(t4) {
              t4.call(a2, n3);
            });
          });
        }
        function $(t2, e3) {
          v2[t2] = v2[t2] || [], v2[t2].push(e3), "update" === t2.split(".")[0] && u2.forEach(function(t3, e4) {
            J("update", e4);
          });
        }
        function G(t2) {
          var n3 = t2 && t2.split(".")[0], i3 = n3 && t2.substring(n3.length);
          Object.keys(v2).forEach(function(t3) {
            var e3 = t3.split(".")[0], r3 = t3.substring(e3.length);
            n3 && n3 !== e3 || i3 && i3 !== r3 || delete v2[t3];
          });
        }
        function J(r3, n3, i3) {
          Object.keys(v2).forEach(function(t2) {
            var e3 = t2.split(".")[0];
            r3 === e3 && v2[t2].forEach(function(t3) {
              t3.call(a2, x2.map(b2.format.to), n3, x2.slice(), i3 || false, S2.slice(), a2);
            });
          });
        }
        function K(t2, e3, r3, n3, i3, o3) {
          var s3;
          return 1 < u2.length && !b2.events.unconstrained && (n3 && 0 < e3 && (s3 = y2.getAbsoluteDistance(t2[e3 - 1], b2.margin, 0), r3 = Math.max(r3, s3)), i3 && e3 < u2.length - 1 && (s3 = y2.getAbsoluteDistance(t2[e3 + 1], b2.margin, 1), r3 = Math.min(r3, s3))), 1 < u2.length && b2.limit && (n3 && 0 < e3 && (s3 = y2.getAbsoluteDistance(t2[e3 - 1], b2.limit, 0), r3 = Math.min(r3, s3)), i3 && e3 < u2.length - 1 && (s3 = y2.getAbsoluteDistance(t2[e3 + 1], b2.limit, 1), r3 = Math.max(r3, s3))), b2.padding && (0 === e3 && (s3 = y2.getAbsoluteDistance(0, b2.padding[0], 0), r3 = Math.max(r3, s3)), e3 === u2.length - 1 && (s3 = y2.getAbsoluteDistance(100, b2.padding[1], 1), r3 = Math.min(r3, s3))), !((r3 = ft(r3 = y2.getStep(r3))) === t2[e3] && !o3) && r3;
        }
        function Q(t2, e3) {
          var r3 = b2.ort;
          return (r3 ? e3 : t2) + ", " + (r3 ? t2 : e3);
        }
        function Z(t2, n3, r3, e3) {
          var i3 = r3.slice(), o3 = [!t2, t2], s3 = [t2, !t2];
          e3 = e3.slice(), t2 && e3.reverse(), 1 < e3.length ? e3.forEach(function(t3, e4) {
            var r4 = K(i3, t3, i3[t3] + n3, o3[e4], s3[e4], false);
            false === r4 ? n3 = 0 : (n3 = r4 - i3[t3], i3[t3] = r4);
          }) : o3 = s3 = [true];
          var a3 = false;
          e3.forEach(function(t3, e4) {
            a3 = rt(t3, r3[t3] + n3, o3[e4], s3[e4]) || a3;
          }), a3 && e3.forEach(function(t3) {
            J("update", t3), J("slide", t3);
          });
        }
        function tt(t2, e3) {
          return b2.dir ? 100 - t2 - e3 : t2;
        }
        function et() {
          m2.forEach(function(t2) {
            var e3 = 50 < S2[t2] ? -1 : 1, r3 = 3 + (u2.length + e3 * t2);
            u2[t2].style.zIndex = r3;
          });
        }
        function rt(t2, e3, r3, n3) {
          return false !== (e3 = K(S2, t2, e3, r3, n3, false)) && (function(t3, e4) {
            S2[t3] = e4, x2[t3] = y2.fromStepping(e4);
            var r4 = "translate(" + Q(10 * (tt(e4, 0) - A2) + "%", "0") + ")";
            u2[t3].style[b2.transformRule] = r4, nt(t3), nt(t3 + 1);
          }(t2, e3), true);
        }
        function nt(t2) {
          if (s2[t2]) {
            var e3 = 0, r3 = 100;
            0 !== t2 && (e3 = S2[t2 - 1]), t2 !== s2.length - 1 && (r3 = S2[t2]);
            var n3 = r3 - e3, i3 = "translate(" + Q(tt(e3, n3) + "%", "0") + ")", o3 = "scale(" + Q(n3 / 100, "1") + ")";
            s2[t2].style[b2.transformRule] = i3 + " " + o3;
          }
        }
        function it(t2, e3) {
          return null === t2 || false === t2 || void 0 === t2 ? S2[e3] : ("number" == typeof t2 && (t2 = String(t2)), t2 = b2.format.from(t2), false === (t2 = y2.toStepping(t2)) || isNaN(t2) ? S2[e3] : t2);
        }
        function ot(t2, e3) {
          var r3 = dt(t2), n3 = void 0 === S2[0];
          e3 = void 0 === e3 || !!e3, b2.animate && !n3 && pt(h2, b2.cssClasses.tap, b2.animationDuration), m2.forEach(function(t3) {
            rt(t3, it(r3[t3], t3), true, false);
          });
          for (var i3 = 1 === m2.length ? 0 : 1; i3 < m2.length; ++i3)
            m2.forEach(function(t3) {
              rt(t3, S2[t3], true, true);
            });
          et(), m2.forEach(function(t3) {
            J("update", t3), null !== r3[t3] && e3 && J("set", t3);
          });
        }
        function st() {
          var t2 = x2.map(b2.format.to);
          return 1 === t2.length ? t2[0] : t2;
        }
        function at(t2) {
          var e3 = S2[t2], r3 = y2.getNearbySteps(e3), n3 = x2[t2], i3 = r3.thisStep.step, o3 = null;
          if (b2.snap)
            return [n3 - r3.stepBefore.startValue || null, r3.stepAfter.startValue - n3 || null];
          false !== i3 && n3 + i3 > r3.stepAfter.startValue && (i3 = r3.stepAfter.startValue - n3), o3 = n3 > r3.thisStep.startValue ? r3.thisStep.step : false !== r3.stepBefore.step && n3 - r3.stepBefore.highestStep, 100 === e3 ? i3 = null : 0 === e3 && (o3 = null);
          var s3 = y2.countStepDecimals();
          return null !== i3 && false !== i3 && (i3 = Number(i3.toFixed(s3))), null !== o3 && false !== o3 && (o3 = Number(o3.toFixed(s3))), [o3, i3];
        }
        return ht(e2 = h2, b2.cssClasses.target), 0 === b2.dir ? ht(e2, b2.cssClasses.ltr) : ht(e2, b2.cssClasses.rtl), 0 === b2.ort ? ht(e2, b2.cssClasses.horizontal) : ht(e2, b2.cssClasses.vertical), ht(
          e2,
          "rtl" === getComputedStyle(e2).direction ? b2.cssClasses.textDirectionRtl : b2.cssClasses.textDirectionLtr
        ), l2 = V2(e2, b2.cssClasses.base), function(t2, e3) {
          var r3 = V2(e3, b2.cssClasses.connects);
          u2 = [], (s2 = []).push(M2(r3, t2[0]));
          for (var n3 = 0; n3 < b2.handles; n3++)
            u2.push(D2(e3, n3)), m2[n3] = n3, s2.push(M2(r3, t2[n3 + 1]));
        }(b2.connect, l2), (p2 = b2.events).fixed || u2.forEach(function(t2, e3) {
          B(f2.start, t2.children[0], I, { handleNumbers: [e3] });
        }), p2.tap && B(f2.start, l2, n2, {}), p2.hover && B(f2.move, l2, W, { hover: true }), p2.drag && s2.forEach(function(t2, e3) {
          if (false !== t2 && 0 !== e3 && e3 !== s2.length - 1) {
            var r3 = u2[e3 - 1], n3 = u2[e3], i3 = [t2];
            ht(t2, b2.cssClasses.draggable), p2.fixed && (i3.push(r3.children[0]), i3.push(n3.children[0])), i3.forEach(function(t3) {
              B(f2.start, t3, I, { handles: [r3, n3], handleNumbers: [e3 - 1, e3] });
            });
          }
        }), ot(b2.start), b2.pips && R(b2.pips), b2.tooltips && H2(), $("update", function(t2, e3, s3, r3, a3) {
          m2.forEach(function(t3) {
            var e4 = u2[t3], r4 = K(S2, t3, 0, true, true, true), n3 = K(S2, t3, 100, true, true, true), i3 = a3[t3], o3 = b2.ariaFormat.to(s3[t3]);
            r4 = y2.fromStepping(r4).toFixed(1), n3 = y2.fromStepping(n3).toFixed(1), i3 = y2.fromStepping(i3).toFixed(1), e4.children[0].setAttribute("aria-valuemin", r4), e4.children[0].setAttribute("aria-valuemax", n3), e4.children[0].setAttribute("aria-valuenow", i3), e4.children[0].setAttribute("aria-valuetext", o3);
          });
        }), a2 = {
          destroy: function() {
            for (var t2 in b2.cssClasses)
              b2.cssClasses.hasOwnProperty(t2) && mt(h2, b2.cssClasses[t2]);
            for (; h2.firstChild; ) h2.removeChild(h2.firstChild);
            delete h2.noUiSlider;
          },
          steps: function() {
            return m2.map(at);
          },
          on: $,
          off: G,
          get: st,
          set: ot,
          setHandle: function(t2, e3, r3) {
            if (!(0 <= (t2 = Number(t2)) && t2 < m2.length))
              throw new Error("noUiSlider (" + lt + "): invalid handle number, got: " + t2);
            rt(t2, it(e3, t2), true, true), J("update", t2), r3 && J("set", t2);
          },
          reset: function(t2) {
            ot(b2.start, t2);
          },
          __moveHandles: function(t2, e3, r3) {
            Z(t2, e3, S2, r3);
          },
          options: o2,
          updateOptions: function(e3, t2) {
            var r3 = st(), n3 = [
              "margin",
              "limit",
              "padding",
              "range",
              "animate",
              "snap",
              "step",
              "format",
              "pips",
              "tooltips"
            ];
            n3.forEach(function(t3) {
              void 0 !== e3[t3] && (o2[t3] = e3[t3]);
            });
            var i3 = vt(o2);
            n3.forEach(function(t3) {
              void 0 !== e3[t3] && (b2[t3] = i3[t3]);
            }), y2 = i3.spectrum, b2.margin = i3.margin, b2.limit = i3.limit, b2.padding = i3.padding, b2.pips ? R(b2.pips) : F(), b2.tooltips ? H2() : z2(), S2 = [], ot(e3.start || r3, t2);
          },
          target: h2,
          removePips: F,
          removeTooltips: z2,
          getTooltips: function() {
            return i2;
          },
          getOrigins: function() {
            return u2;
          },
          pips: R
        };
      }
      return {
        __spectrum: i,
        version: lt,
        cssClasses: d,
        create: function(t, e2) {
          if (!t || !t.nodeName)
            throw new Error(
              "noUiSlider (" + lt + "): create requires a single element, got: " + t
            );
          if (t.noUiSlider)
            throw new Error("noUiSlider (" + lt + "): Slider was already initialized.");
          var r2 = j(t, vt(e2), e2);
          return t.noUiSlider = r2;
        }
      };
    });
  }
});
export default require_nouislider_min();
/*! Bundled license information:

svelte-materialify/dist/components/Slider/nouislider.min.js:
  (*! nouislider - 14.6.1 - 8/17/2020 *)
*/
//# sourceMappingURL=nouislider.min-X4NE2HQL.js.map
